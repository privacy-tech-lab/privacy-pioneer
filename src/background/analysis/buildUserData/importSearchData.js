/*
Licensed per https://github.com/privacy-tech-lab/privacy-pioneer/blob/main/LICENSE
privacy-tech-lab, https://privacytechlab.org/
*/

/*
importSearchData.js
================================================================================
- importSearchData.js is the file that handles all the get functions to create
both the URL and the keyword list for words and URLs to look for in the
network requests
*/
import { getLocationData } from "./getLocationData.js";
import {
  buildPhone,
  getRegion,
  buildIpRegex,
  buildZipRegex,
  buildGeneralRegex,
} from "./structuredRoutines.js";
import {
  typeEnum,
  permissionEnum,
  settingsModelsEnum,
  KeywordObject,
} from "../classModels.js";
import {
  setEmail,
  digestMessage,
  hexToBase64,
} from "../requestAnalysis/encodedEmail.js";
import {
  getWatchlistDict,
  hashUserDictValues,
  createKeywordObj,
} from "./structureUserData.js";
import { watchlistHashGen } from "../utility/util.js";
import {
  analyticsKeyval,
  settingsKeyval,
} from "../../../libs/indexed-db/openDB.js";
import { apiIPToken } from "../../../libs/holdAPI.js";
import { getIpInfo } from "./userIPInfo.js";
import { saveKeyword } from "../../../libs/indexed-db/updateWatchlist.js";
import { watchlistKeyval } from "../../../libs/indexed-db/openDB.js";

// import keywords, services JSONs
const keywords = require("../../../assets/keywords.json");

export var IPINFO_IPKEY = "1111111111";
export var IPINFO_ADDRESSKEY = "2222222222";

/**
 * Used to build all the data we search for in our analysis. This includes data in the watchlist DB and the JSON lists.
 *
 * Defined in importSearchData.js
 *
 * Used in background.js
 *
 * @returns {Promise<any[]>} [locCoords, networkKeywords]
 *
 * locCoords: Length 2 array of [lat, lng]
 *
 * networkKeywods: Dictionary with permissionEnum outer keys and typeEnum inner keys. Values are stored as arrays
 */
export async function importData() {
  var networkKeywords = {};
  // watchlist == data entered by the user in our extension
  // ex phone numbers, emails, etc
  networkKeywords[permissionEnum.personal] = {};

  // first let's build up the location info
  var locCoords = await getLocationData();
  var ret = await fetch("http://ipinfo.io/json?token" + apiIPToken);
  var retJson = await ret.json();
  var currIpInfo = await getIpInfo(retJson);
  let user_tempStore_dict = await getWatchlistDict();

  //This should only execute on the first download
  //It adds IP Address and Street Address keywords generated by ipinfo to Watchlist
  if (user_tempStore_dict[typeEnum.ipAddress] == undefined) {
    let locKey;
    await saveKeyword(retJson.ip, typeEnum.ipAddress, "ip");
    locKey = {
      [typeEnum.streetAddress]: null,
      [typeEnum.zipCode]: retJson.postal,
      [typeEnum.region]: retJson.region,
      [typeEnum.city]: retJson.city,
      display: `${""} ${retJson.city}, ${retJson.region} ${retJson.postal}`,
    };
    await saveKeyword(locKey, permissionEnum.location, "loc");
  }

  //This checks to see if the ipinfo generated keywords are up to date with users current location
  let keywordObject = await watchlistKeyval.get(IPINFO_IPKEY);
  for (let [t, val] of Object.entries(keywordObject)) {
    if (t == "keyword") {
      //If the useres watchlist is not current, then update it
      if (val != retJson.ip) {
        await watchlistKeyval.set(IPINFO_IPKEY, {
          keyword: retJson.ip,
          type: "ipAddress",
          id: IPINFO_IPKEY,
          notification: Notification.permission == "granted",
        });
        let locKey;
        locKey = {
          [typeEnum.streetAddress]: null,
          [typeEnum.zipCode]: retJson.postal,
          [typeEnum.region]: retJson.region,
          [typeEnum.city]: retJson.city,
          display: `${""} ${retJson.city}, ${retJson.region} ${retJson.postal}`,
        };
        await saveKeyword(locKey, permissionEnum.location, "loc");
      }
    }
  }
  let user_store_dict = await getWatchlistDict();
  // get formatted data from the watchlist store
  // at bottom of file

  // format every phone stored
  var userPhone;
  if (typeEnum.phoneNumber in user_store_dict) {
    userPhone = [];
    let phone_arr = user_store_dict[typeEnum.phoneNumber];
    phone_arr.forEach((phone) => {
      const origHash = watchlistHashGen(typeEnum.phoneNumber, phone);
      // creates an array of possible re-configurations for each number
      let format_arr = buildPhone(phone);
      format_arr.forEach((format) => {
        userPhone.push(
          createKeywordObj(format, typeEnum.phoneNumber, origHash)
        );
      });
    });
  }

  // if we have a phone we put it in the network keywords dict
  if (typeof userPhone !== "undefined") {
    networkKeywords[permissionEnum.personal][typeEnum.phoneNumber] = userPhone;
  }

  // build location Elements
  var locElems = {};

  if (typeEnum.zipCode in user_store_dict) {
    const userZip = user_store_dict[typeEnum.zipCode];
    var userZipArr = [];
    userZip.forEach((zip) => {
      const locHash = zip[1];
      const zipRegex = buildZipRegex(zip[0]);
      const zipObj = new KeywordObject({
        keyword: zipRegex,
        keywordHash: locHash,
      });
      userZipArr.push(zipObj);
    });

    locElems[typeEnum.zipCode] = userZipArr;
  }

  if (typeEnum.region in user_store_dict) {
    // init the arr if we didn't grab it from the zip above
    locElems[typeEnum.region] = [];
    const userRegion = user_store_dict[typeEnum.region];
    userRegion.forEach((region) => {
      if (!locElems[typeEnum.region].includes(region[0])) {
        var regex = getRegion(region[0]);
        locElems[typeEnum.region].push(
          new KeywordObject({ keyword: regex, keywordHash: region[1] })
        );
      }
    });
  }

  if (typeEnum.city in user_store_dict) {
    var cityArr = [];
    const userCity = user_store_dict[typeEnum.city];
    userCity.forEach((city) => {
      cityArr.push(
        new KeywordObject({ keyword: city[0], keywordHash: city[1] })
      );
    });
    locElems[typeEnum.city] = cityArr;
  }

  if (typeEnum.streetAddress in user_store_dict) {
    var addrArr = [];
    const userAddress = user_store_dict[typeEnum.streetAddress];
    userAddress.forEach((addr) => {
      addrArr.push(
        new KeywordObject({ keyword: addr[0], keywordHash: addr[1] })
      );
    });
    locElems[typeEnum.streetAddress] = addrArr;
  }
  networkKeywords[permissionEnum.location] = locElems;

  // if the user entered an email/s, add it to network keywords (formated as arr)
  if (typeEnum.emailAddress in user_store_dict) {
    var normalEmails = [];
    var encodedEmails = {};
    user_store_dict[typeEnum.emailAddress].forEach(async (email) => {
      const emailSet = setEmail(email);

      // add the normal email as a regex where the non alphanumeric characters are possibly changed or not present
      const newEmail = createKeywordObj(
        new RegExp(buildGeneralRegex(email)),
        typeEnum.emailAddress,
        watchlistHashGen(typeEnum.emailAddress, emailSet)
      );
      normalEmails.push(newEmail);

      // add encoded emails
      const digestHex = await digestMessage(emailSet);
      const base64Encoded = hexToBase64(digestHex);
      const urlBase64Encoded = encodeURIComponent(base64Encoded);
      const origHash = watchlistHashGen(typeEnum.emailAddress, emailSet);
      const base64EncodedObj = createKeywordObj(
        base64Encoded,
        typeEnum.emailAddress,
        origHash
      );
      const urlBase64EncodedObj = createKeywordObj(
        urlBase64Encoded,
        typeEnum.emailAddress,
        origHash
      );
      encodedEmails[email] = [base64EncodedObj, urlBase64EncodedObj];
    });

    networkKeywords[permissionEnum.personal][typeEnum.emailAddress] =
      normalEmails;
    networkKeywords[permissionEnum.personal][typeEnum.encodedEmail] =
      encodedEmails;
  }

  // if we have user keywords, we add them to the network keywords (formated as arr)
  if (typeEnum.userKeyword in user_store_dict) {
    var regexKeywords = [];
    user_store_dict[typeEnum.userKeyword].forEach(async (keyword) => {
      const wordRegex = buildGeneralRegex(keyword);
      const origHash = watchlistHashGen(typeEnum.userKeyword, keyword);
      const wordObj = createKeywordObj(
        wordRegex,
        typeEnum.userKeyword,
        origHash
      );
      regexKeywords.push(wordObj);
    });
    networkKeywords[permissionEnum.personal][typeEnum.userKeyword] =
      regexKeywords;
  }

  if (typeEnum.ipAddress in user_store_dict) {
    var ipArr = [];
    for (const ip of user_store_dict[typeEnum.ipAddress]) {
      /**
       * @type {number|string}
       */
      let origHash = "";
      if (retJson.ip === ip) {
        origHash = IPINFO_IPKEY;
      } else {
        origHash = watchlistHashGen(typeEnum.ipAddress, ip);
      }
      const ipRegex = buildIpRegex(ip);
      // @ts-ignore
      const ipObj = createKeywordObj(ipRegex, typeEnum.ipAddress, origHash);
      ipArr.push(ipObj);
    }
    networkKeywords[permissionEnum.personal][typeEnum.ipAddress] = ipArr;
  }

  // build tracking info
  networkKeywords[permissionEnum.tracking] = {};
  networkKeywords[permissionEnum.tracking][typeEnum.trackingPixel] =
    keywords["PIXEL"]["URLs"];

  // build fingerprinting info. Adding fingerprinting library keywords,
  // JSON list methods
  networkKeywords[permissionEnum.tracking][typeEnum.fingerprinting] =
    keywords["FINGERPRINT"]["fpLibraryList"];

  networkKeywords = hashUserDictValues(networkKeywords);

  const analytic = await analyticsKeyval.get(settingsModelsEnum.analytics);

  // returns [location we obtained from google maps API, {phone #s, emails,
  // location elements entered by the user, fingerprinting keywords}, the user's choice to or
  // performance, the user's current location and IP address as provided by
  // ipinfo.io]

  return [
    locCoords,
    networkKeywords,
    currIpInfo,
    analytic,
  ];
}